"""
Event Handlers para eventos relacionados a tickets.

Processa eventos de dom√≠nio para implementar side effects
como notifica√ß√µes, logs de auditoria e sincroniza√ß√£o com sistemas externos.
"""

import asyncio
import logging
from typing import Type

from ..event_bus import EventHandler, DomainEvent
from ....domain.events.ticket_events import (
    TicketCreated,
    TicketAssigned,
    TicketStatusChanged,
    TicketSyncedWithHubSoft
)

logger = logging.getLogger(__name__)


class TicketCreatedHandler(EventHandler):
    """
    Handler para evento de ticket criado.

    Responsabilidades:
    - Log de auditoria
    - Notifica√ß√£o para administradores
    - Prepara√ß√£o para sincroniza√ß√£o com HubSoft
    """

    @property
    def event_type(self) -> Type[DomainEvent]:
        return TicketCreated

    async def handle(self, event: TicketCreated) -> None:
        """
        Processa evento de ticket criado.

        Args:
            event: Evento de ticket criado
        """
        logger.info(
            f"üìù TICKET CRIADO: {event.ticket_id} por usu√°rio {event.user_id} "
            f"- Categoria: {event.category} - Protocolo: {event.protocol}"
        )

        # Simula notifica√ß√£o para admins (em produ√ß√£o seria via Telegram)
        await self._notify_admins_new_ticket(event)

        # Simula prepara√ß√£o para sync com HubSoft
        await self._prepare_hubsoft_sync(event)

    async def _notify_admins_new_ticket(self, event: TicketCreated) -> None:
        """
        Notifica administradores sobre novo ticket.

        Args:
            event: Evento de ticket criado
        """
        try:
            # Em produ√ß√£o, enviar notifica√ß√£o real via Telegram Bot API
            logger.info(
                f"üì¢ NOTIFICA√á√ÉO ADMIN: Novo ticket {event.protocol} "
                f"criado por {event.username} - {event.category}"
            )

            # Simula delay de notifica√ß√£o
            await asyncio.sleep(0.1)

        except Exception as e:
            logger.error(f"Erro ao notificar admins sobre ticket {event.ticket_id}: {e}")

    async def _prepare_hubsoft_sync(self, event: TicketCreated) -> None:
        """
        Prepara dados para sincroniza√ß√£o com HubSoft.

        Args:
            event: Evento de ticket criado
        """
        try:
            # Em produ√ß√£o, adicionaria √† fila de sincroniza√ß√£o
            logger.debug(
                f"üîÑ SYNC PREPARADO: Ticket {event.ticket_id} "
                f"adicionado √† fila de sincroniza√ß√£o HubSoft"
            )

        except Exception as e:
            logger.error(f"Erro ao preparar sync para ticket {event.ticket_id}: {e}")


class TicketAssignedHandler(EventHandler):
    """
    Handler para evento de ticket atribu√≠do.

    Responsabilidades:
    - Notifica√ß√£o para o t√©cnico designado
    - Atualiza√ß√£o de m√©tricas de workload
    - Log de atribui√ß√£o
    """

    @property
    def event_type(self) -> Type[DomainEvent]:
        return TicketAssigned

    async def handle(self, event: TicketAssigned) -> None:
        """
        Processa evento de ticket atribu√≠do.

        Args:
            event: Evento de ticket atribu√≠do
        """
        logger.info(
            f"üë§ TICKET ATRIBU√çDO: {event.ticket_id} ‚Üí {event.technician} "
            f"(Status: {event.status})"
        )

        # Notifica t√©cnico (em produ√ß√£o seria via Telegram/email)
        await self._notify_technician(event)

        # Atualiza m√©tricas de workload
        await self._update_workload_metrics(event)

    async def _notify_technician(self, event: TicketAssigned) -> None:
        """
        Notifica t√©cnico sobre atribui√ß√£o.

        Args:
            event: Evento de ticket atribu√≠do
        """
        try:
            logger.info(
                f"üì® NOTIFICA√á√ÉO T√âCNICO: {event.technician} "
                f"recebeu ticket {event.ticket_id}"
            )

            # Simula envio de notifica√ß√£o
            await asyncio.sleep(0.1)

        except Exception as e:
            logger.error(f"Erro ao notificar t√©cnico sobre ticket {event.ticket_id}: {e}")

    async def _update_workload_metrics(self, event: TicketAssigned) -> None:
        """
        Atualiza m√©tricas de carga de trabalho.

        Args:
            event: Evento de ticket atribu√≠do
        """
        try:
            # Em produ√ß√£o, atualizaria m√©tricas reais
            logger.debug(
                f"üìä M√âTRICAS: Workload atualizado para {event.technician} "
                f"(+1 ticket ativo)"
            )

        except Exception as e:
            logger.error(f"Erro ao atualizar m√©tricas para ticket {event.ticket_id}: {e}")


class TicketStatusChangedHandler(EventHandler):
    """
    Handler para evento de mudan√ßa de status.

    Responsabilidades:
    - Log de auditoria de mudan√ßas
    - Notifica√ß√£o para usu√°rio sobre progresso
    - Atualiza√ß√£o de dashboards
    """

    @property
    def event_type(self) -> Type[DomainEvent]:
        return TicketStatusChanged

    async def handle(self, event: TicketStatusChanged) -> None:
        """
        Processa evento de mudan√ßa de status.

        Args:
            event: Evento de mudan√ßa de status
        """
        logger.info(
            f"üîÑ STATUS ALTERADO: Ticket {event.ticket_id} "
            f"{event.old_status} ‚Üí {event.new_status}"
        )

        # Notifica usu√°rio sobre mudan√ßa
        await self._notify_user_status_change(event)

        # Atualiza dashboards
        await self._update_dashboards(event)

        # L√≥gica especial para tickets resolvidos
        if event.new_status == "RESOLVED":
            await self._handle_ticket_resolved(event)

    async def _notify_user_status_change(self, event: TicketStatusChanged) -> None:
        """
        Notifica usu√°rio sobre mudan√ßa de status.

        Args:
            event: Evento de mudan√ßa de status
        """
        try:
            status_messages = {
                "OPEN": "üì© Seu ticket foi aberto e est√° sendo analisado",
                "IN_PROGRESS": "üîß T√©cnico est√° trabalhando no seu ticket",
                "RESOLVED": "‚úÖ Seu ticket foi resolvido!",
                "CLOSED": "üìù Ticket finalizado. Obrigado pelo contato!"
            }

            message = status_messages.get(event.new_status, "Ticket atualizado")

            logger.info(
                f"üí¨ NOTIFICA√á√ÉO USU√ÅRIO: {event.user_id} - {message} "
                f"(Ticket: {event.ticket_id})"
            )

        except Exception as e:
            logger.error(f"Erro ao notificar usu√°rio sobre ticket {event.ticket_id}: {e}")

    async def _update_dashboards(self, event: TicketStatusChanged) -> None:
        """
        Atualiza dashboards com nova informa√ß√£o.

        Args:
            event: Evento de mudan√ßa de status
        """
        try:
            logger.debug(
                f"üìà DASHBOARD: M√©tricas atualizadas para mudan√ßa "
                f"{event.old_status} ‚Üí {event.new_status}"
            )

        except Exception as e:
            logger.error(f"Erro ao atualizar dashboard para ticket {event.ticket_id}: {e}")

    async def _handle_ticket_resolved(self, event: TicketStatusChanged) -> None:
        """
        L√≥gica especial para tickets resolvidos.

        Args:
            event: Evento de mudan√ßa de status
        """
        try:
            logger.info(
                f"üéâ TICKET RESOLVIDO: {event.ticket_id} "
                f"- Iniciando processo de feedback"
            )

            # Em produ√ß√£o, iniciaria processo de feedback automatizado

        except Exception as e:
            logger.error(f"Erro no processo de resolu√ß√£o para ticket {event.ticket_id}: {e}")


class TicketSyncedHandler(EventHandler):
    """
    Handler para evento de sincroniza√ß√£o com HubSoft.

    Responsabilidades:
    - Log de sincroniza√ß√£o bem-sucedida
    - Atualiza√ß√£o de status de sync
    - Retry logic para falhas
    """

    @property
    def event_type(self) -> Type[DomainEvent]:
        return TicketSyncedWithHubSoft

    async def handle(self, event: TicketSyncedWithHubSoft) -> None:
        """
        Processa evento de sincroniza√ß√£o com HubSoft.

        Args:
            event: Evento de sincroniza√ß√£o
        """
        logger.info(
            f"üîó HUBSOFT SYNC: Ticket {event.ticket_id} "
            f"sincronizado com HubSoft ID: {event.hubsoft_id}"
        )

        # Atualiza status de sincroniza√ß√£o
        await self._update_sync_status(event)

        # Valida integridade dos dados
        await self._validate_sync_integrity(event)

    async def _update_sync_status(self, event: TicketSyncedWithHubSoft) -> None:
        """
        Atualiza status de sincroniza√ß√£o.

        Args:
            event: Evento de sincroniza√ß√£o
        """
        try:
            logger.debug(
                f"‚úÖ SYNC STATUS: Ticket {event.ticket_id} "
                f"marcado como sincronizado"
            )

        except Exception as e:
            logger.error(f"Erro ao atualizar status de sync para ticket {event.ticket_id}: {e}")

    async def _validate_sync_integrity(self, event: TicketSyncedWithHubSoft) -> None:
        """
        Valida integridade da sincroniza√ß√£o.

        Args:
            event: Evento de sincroniza√ß√£o
        """
        try:
            # Em produ√ß√£o, validaria dados no HubSoft
            logger.debug(
                f"üîç VALIDA√á√ÉO: Integridade confirmada para sync "
                f"{event.ticket_id} ‚Üî {event.hubsoft_id}"
            )

        except Exception as e:
            logger.error(f"Erro na valida√ß√£o de sync para ticket {event.ticket_id}: {e}")


class TicketAuditHandler(EventHandler):
    """
    Handler global para auditoria de todos eventos de ticket.

    Responsabilidades:
    - Log detalhado de auditoria
    - Armazenamento para compliance
    - M√©tricas gerais do sistema
    """

    @property
    def event_type(self) -> Type[DomainEvent]:
        # Este handler ser√° registrado como global
        return DomainEvent

    async def handle(self, event: DomainEvent) -> None:
        """
        Processa qualquer evento para auditoria.

        Args:
            event: Qualquer evento de dom√≠nio
        """
        # S√≥ processa eventos relacionados a tickets
        if not any(keyword in event.__class__.__name__ for keyword in ['Ticket', 'Conversation']):
            return

        logger.info(
            f"üìã AUDITORIA: {event.__class__.__name__} "
            f"em {event.occurred_at.strftime('%Y-%m-%d %H:%M:%S')}"
        )

        # Em produ√ß√£o, salvaria em sistema de auditoria
        await self._save_audit_log(event)

    async def _save_audit_log(self, event: DomainEvent) -> None:
        """
        Salva log de auditoria.

        Args:
            event: Evento a ser auditado
        """
        try:
            # Em produ√ß√£o, salvaria em banco de dados de auditoria
            logger.debug(f"üíæ AUDIT LOG: {event.__class__.__name__} salvo para auditoria")

        except Exception as e:
            logger.error(f"Erro ao salvar audit log: {e}")