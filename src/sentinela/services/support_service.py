import logging
import json
from datetime import datetime, timedelta
from telegram import Bot, InlineKeyboardButton, InlineKeyboardMarkup

from src.sentinela.core.config import TELEGRAM_TOKEN, TELEGRAM_GROUP_ID
from src.sentinela.clients.db_client import (
    can_create_support_ticket, start_support_conversation, get_support_conversation,
    update_support_conversation, save_support_ticket, get_user_data, get_active_support_tickets
)

logger = logging.getLogger(__name__)

class SupportFormManager:
    """Gerencia o formul√°rio conversacional de suporte"""

    # Configura√ß√£o dos passos do formul√°rio
    STEPS = {
        1: "category_selection",
        2: "game_selection",
        3: "timing_selection",
        4: "description_input",
        5: "attachments_optional",
        6: "confirmation"
    }

    # Categorias de problemas
    CATEGORIES = {
        "connectivity": "üåê Conectividade/Ping",
        "performance": "üéÆ Performance em Jogos",
        "configuration": "‚öôÔ∏è Configura√ß√£o/Otimiza√ß√£o",
        "equipment": "üîß Problema com Equipamento",
        "other": "üìû Outro"
    }

    # Jogos populares
    POPULAR_GAMES = {
        "valorant": "‚ö°Ô∏è Valorant",
        "cs2": "üéØ CS2",
        "lol": "üèÜ League of Legends",
        "fortnite": "üåç Fortnite",
        "apex": "üéÆ Apex Legends",
        "overwatch": "ü¶∏ Overwatch 2",
        "mobile_legends": "üì± Mobile Legends",
        "dota2": "‚öîÔ∏è Dota 2",
        "all_games": "üåê Todos os jogos",
        "other_game": "üìù Outro jogo"
    }

    # Op√ß√µes de tempo
    TIMING_OPTIONS = {
        "now": "üö® Agora mesmo / Hoje",
        "yesterday": "üìÖ Ontem",
        "this_week": "üìÜ Esta semana",
        "last_week": "üóìÔ∏è Semana passada",
        "long_time": "‚è≥ H√° mais tempo",
        "always": "üîÑ Sempre foi assim"
    }

async def handle_support_request(user_id: int, username: str, user_mention: str):
    """
    Inicia processo de suporte para o usu√°rio.

    Args:
        user_id: ID do usu√°rio no Telegram
        username: Nome de usu√°rio
        user_mention: Mention formatado do usu√°rio
    """
    try:
        # Verifica se pode criar ticket (anti-spam)
        permission = can_create_support_ticket(user_id)

        if not permission['can_create']:
            await send_support_blocked_message(user_id, permission)
            return

        # Busca dados do cliente no banco
        user_data = get_user_data(user_id)
        if not user_data:
            await send_client_not_found_message(user_id)
            return

        # Inicia conversa de formul√°rio
        if start_support_conversation(user_id, username):
            await send_welcome_support_message(user_id, user_data, user_mention)
        else:
            await send_error_message(user_id, "Erro ao iniciar formul√°rio de suporte")

    except Exception as e:
        logger.error(f"Erro ao processar solicita√ß√£o de suporte para {username}: {e}")
        await send_error_message(user_id, "Erro interno no sistema de suporte")

async def handle_support_message(user_id: int, message_text: str, username: str):
    """
    Processa mensagem durante o formul√°rio de suporte.

    Args:
        user_id: ID do usu√°rio
        message_text: Texto da mensagem
        username: Nome de usu√°rio
    """
    try:
        # Busca conversa ativa
        conversation = get_support_conversation(user_id)
        if not conversation:
            return False  # N√£o √© conversa de suporte

        current_step = conversation['current_step']
        form_data = json.loads(conversation['form_data'] or '{}')

        # Processa baseado no passo atual
        if current_step == 4:  # Descri√ß√£o detalhada
            await process_description_step(user_id, message_text, form_data, username)
        elif message_text.startswith('/') or message_text in ['üìù Outro jogo', 'üìû Outro']:
            await process_other_input(user_id, message_text, current_step, form_data)

        return True  # Mensagem processada

    except Exception as e:
        logger.error(f"Erro ao processar mensagem de suporte de {username}: {e}")
        return False

async def handle_photo_attachment(user_id: int, photo, username: str):
    """
    Processa anexo de foto durante o formul√°rio de suporte.
    """
    try:
        # Verifica se est√° em conversa de suporte ativa
        conversation = get_support_conversation(user_id)
        if not conversation:
            await send_photo_not_in_support(user_id)
            return False

        current_step = conversation['current_step']
        form_data = json.loads(conversation['form_data'] or '{}')

        # S√≥ aceita fotos no passo 5 (anexos) e se estiver aguardando imagens
        if current_step != 5 or not form_data.get('waiting_for_images'):
            await send_photo_not_expected(user_id)
            return False

        # Verifica limite de anexos (m√°ximo 3)
        attachments = form_data.get('attachments', [])
        if len(attachments) >= 3:
            await send_max_attachments_reached(user_id)
            return False

        # Processa a imagem
        await process_photo_attachment(user_id, photo, form_data, username)
        return True

    except Exception as e:
        logger.error(f"Erro ao processar anexo de foto de {username}: {e}")
        return False

async def process_photo_attachment(user_id: int, photo, form_data: dict, username: str):
    """Processa e salva anexo de foto"""
    try:
        from telegram import Bot
        import os
        import tempfile

        # Download da foto
        bot = Bot(token=TELEGRAM_TOKEN)
        async with bot:
            file = await bot.get_file(photo.file_id)

            # Cria diret√≥rio tempor√°rio se n√£o existir
            temp_dir = os.path.join(tempfile.gettempdir(), 'sentinela_attachments')
            os.makedirs(temp_dir, exist_ok=True)

            # Nome do arquivo baseado no user_id e timestamp
            file_extension = file.file_path.split('.')[-1] if '.' in file.file_path else 'jpg'
            filename = f"attachment_{user_id}_{len(form_data.get('attachments', []))+1}.{file_extension}"
            file_path = os.path.join(temp_dir, filename)

            # Download do arquivo
            await file.download_to_drive(file_path)

        # Adiciona aos anexos
        attachments = form_data.get('attachments', [])
        attachments.append({
            'file_id': photo.file_id,
            'file_path': file_path,
            'filename': filename,
            'file_size': photo.file_size
        })
        form_data['attachments'] = attachments

        # Atualiza conversa
        update_support_conversation(user_id, 5, 'attachments_optional', json.dumps(form_data))

        # Confirma recebimento
        await send_photo_received_confirmation(user_id, len(attachments))

    except Exception as e:
        logger.error(f"Erro ao processar foto de {username}: {e}")
        await send_photo_processing_error(user_id)

async def send_photo_not_in_support(user_id: int):
    """Informa que n√£o est√° em processo de suporte"""
    try:
        bot = Bot(token=TELEGRAM_TOKEN)
        async with bot:
            await bot.send_message(
                chat_id=user_id,
                text="üì∏ Foto recebida, mas voc√™ n√£o est√° em processo de cria√ß√£o de atendimento.\n\n"
                     "Use /suporte para iniciar um novo atendimento.",
                parse_mode='HTML'
            )
    except Exception as e:
        logger.error(f"Erro ao enviar mensagem de foto fora de suporte: {e}")

async def send_photo_not_expected(user_id: int):
    """Informa que n√£o √© o momento de enviar fotos"""
    try:
        bot = Bot(token=TELEGRAM_TOKEN)
        async with bot:
            await bot.send_message(
                chat_id=user_id,
                text="üì∏ Foto recebida, mas n√£o √© o momento de anexar imagens.\n\n"
                     "Complete o formul√°rio atual primeiro.",
                parse_mode='HTML'
            )
    except Exception as e:
        logger.error(f"Erro ao enviar mensagem de foto n√£o esperada: {e}")

async def send_max_attachments_reached(user_id: int):
    """Informa que atingiu limite de anexos"""
    try:
        bot = Bot(token=TELEGRAM_TOKEN)
        async with bot:
            await bot.send_message(
                chat_id=user_id,
                text="üìé <b>Limite de anexos atingido!</b>\n\n"
                     "Voc√™ j√° anexou 3 imagens (limite m√°ximo).\n\n"
                     "Clique em <b>'Finalizar anexos'</b> para continuar.",
                parse_mode='HTML'
            )
    except Exception as e:
        logger.error(f"Erro ao enviar mensagem de limite de anexos: {e}")

async def send_photo_received_confirmation(user_id: int, total_attachments: int):
    """Confirma recebimento da foto"""
    try:
        remaining = 3 - total_attachments
        message = (
            f"‚úÖ <b>Imagem {total_attachments}/3 recebida!</b>\n\n"
            f"üìé Total de anexos: {total_attachments}\n"
        )

        if remaining > 0:
            message += f"üì§ Voc√™ pode enviar mais {remaining} imagem(ns) ou clicar em 'Finalizar anexos'."
        else:
            message += f"üî• Limite m√°ximo atingido! Clique em 'Finalizar anexos' para continuar."

        bot = Bot(token=TELEGRAM_TOKEN)
        async with bot:
            await bot.send_message(
                chat_id=user_id,
                text=message,
                parse_mode='HTML'
            )
    except Exception as e:
        logger.error(f"Erro ao enviar confirma√ß√£o de foto: {e}")

async def send_photo_processing_error(user_id: int):
    """Informa erro no processamento da foto"""
    try:
        bot = Bot(token=TELEGRAM_TOKEN)
        async with bot:
            await bot.send_message(
                chat_id=user_id,
                text="‚ùå <b>Erro ao processar imagem</b>\n\n"
                     "Ocorreu um erro ao salvar sua imagem. Tente enviar novamente ou continue sem anexos.",
                parse_mode='HTML'
            )
    except Exception as e:
        logger.error(f"Erro ao enviar mensagem de erro de processamento: {e}")

async def process_hubsoft_attachments(hubsoft_id: str, attachments: list, username: str):
    """Processa e envia anexos para o HubSoft"""
    try:
        from src.sentinela.integrations.hubsoft.atendimento import hubsoft_atendimento_client
        import os

        logger.info(f"Enviando {len(attachments)} anexo(s) para HubSoft - atendimento {hubsoft_id}")

        for i, attachment in enumerate(attachments, 1):
            try:
                file_path = attachment.get('file_path')
                filename = attachment.get('filename', f'anexo_{i}.jpg')

                if not file_path or not os.path.exists(file_path):
                    logger.warning(f"Arquivo n√£o encontrado: {file_path}")
                    continue

                # L√™ o arquivo
                with open(file_path, 'rb') as file:
                    file_content = file.read()

                # Envia para HubSoft
                success = await hubsoft_atendimento_client.add_attachment_to_atendimento(
                    hubsoft_id,
                    file_content,
                    filename
                )

                if success:
                    logger.info(f"Anexo {i} enviado com sucesso: {filename}")
                else:
                    logger.warning(f"Falha ao enviar anexo {i}: {filename}")

                # Remove arquivo tempor√°rio ap√≥s envio
                try:
                    os.remove(file_path)
                    logger.debug(f"Arquivo tempor√°rio removido: {file_path}")
                except Exception as remove_error:
                    logger.warning(f"Erro ao remover arquivo tempor√°rio {file_path}: {remove_error}")

            except Exception as attachment_error:
                logger.error(f"Erro ao processar anexo {i} para {username}: {attachment_error}")

        logger.info(f"Processamento de anexos conclu√≠do para atendimento {hubsoft_id}")

    except Exception as e:
        logger.error(f"Erro geral ao processar anexos HubSoft para {username}: {e}")

async def handle_support_callback(user_id: int, callback_data: str, username: str):
    """
    Processa cliques em bot√µes do formul√°rio de suporte.

    Args:
        user_id: ID do usu√°rio
        callback_data: Dados do callback
        username: Nome de usu√°rio
    """
    try:
        conversation = get_support_conversation(user_id)
        if not conversation:
            return False

        current_step = conversation['current_step']
        form_data = json.loads(conversation['form_data'] or '{}')

        # Remove prefixo 'support_'
        action = callback_data.replace('support_', '') if callback_data.startswith('support_') else callback_data

        if current_step == 1:  # Categoria
            await process_category_selection(user_id, action, form_data, username)
        elif current_step == 2:  # Jogo
            await process_game_selection(user_id, action, form_data, username)
        elif current_step == 3:  # Timing
            await process_timing_selection(user_id, action, form_data, username)
        elif current_step == 5:  # Anexos opcionais
            await process_attachments_step(user_id, action, form_data, username)
        elif current_step == 6:  # Confirma√ß√£o
            await process_confirmation(user_id, action, form_data, username)

        return True

    except Exception as e:
        logger.error(f"Erro ao processar callback de suporte de {username}: {e}")
        return False

async def send_welcome_support_message(user_id: int, user_data: dict, user_mention: str):
    """Envia mensagem de boas-vindas do formul√°rio de suporte"""
    try:
        client_name = user_data.get('client_name', 'Cliente')
        service_name = user_data.get('service_name', 'Plano OnCabo')

        # Calcula tempo como cliente (aproximado)
        created_at = user_data.get('created_at', '')
        time_as_client = "Cliente OnCabo"
        if created_at:
            try:
                created_date = datetime.fromisoformat(created_at.replace('Z', '+00:00'))
                days_diff = (datetime.now() - created_date).days
                if days_diff < 30:
                    time_as_client = f"Cliente h√° {days_diff} dias"
                elif days_diff < 365:
                    time_as_client = f"Cliente h√° {days_diff//30} meses"
                else:
                    time_as_client = f"Cliente h√° {days_diff//365} anos"
            except:
                pass

        welcome_text = (
            f"üéÆ <b>Ol√°, {client_name}!</b>\n\n"
            f"Sou o assistente virtual da OnCabo e estou aqui para te ajudar com qualquer problema de gaming! üí™\n\n"
            f"üîç Vejo que voc√™ √© <b>{time_as_client}</b> e tem o <b>{service_name}</b> - perfeito para gaming!\n\n"
            f"Vamos resolver seu problema juntos? Preciso de algumas informa√ß√µes para criar seu atendimento oficial no nosso sistema.\n\n"
            f"‚è±Ô∏è Levar√° apenas <b>2-3 minutos</b> e voc√™ ter√° um protocolo para acompanhar.\n\n"
            f"üöÄ <b>Vamos come√ßar?</b>"
        )

        # Cria bot√µes para categorias
        keyboard = create_category_keyboard()

        bot = Bot(token=TELEGRAM_TOKEN)
        async with bot:
            await bot.send_message(
                chat_id=user_id,
                text=welcome_text,
                parse_mode='HTML',
                reply_markup=keyboard
            )

            # Envia progress bar
            progress_text = "üéØ <b>CRIANDO SEU ATENDIMENTO</b> [‚ñì‚ñë‚ñë‚ñë‚ñë‚ñë] 1/6\n\n‚úÖ Iniciado\nüîÑ Tipo do problema...\n‚è≥ Jogo afetado...\n‚è≥ Quando come√ßou...\n‚è≥ Detalhes...\n‚è≥ Anexos (opcional)...\n‚è≥ Confirma√ß√£o..."
            await bot.send_message(
                chat_id=user_id,
                text=progress_text,
                parse_mode='HTML'
            )

    except Exception as e:
        logger.error(f"Erro ao enviar mensagem de boas-vindas de suporte: {e}")

def create_category_keyboard():
    """Cria teclado inline para sele√ß√£o de categoria"""
    keyboard = []
    for key, value in SupportFormManager.CATEGORIES.items():
        keyboard.append([InlineKeyboardButton(value, callback_data=f"support_{key}")])

    return InlineKeyboardMarkup(keyboard)

def create_game_keyboard():
    """Cria teclado inline para sele√ß√£o de jogo"""
    keyboard = []
    games = list(SupportFormManager.POPULAR_GAMES.items())

    # Organiza em pares para layout mais compacto
    for i in range(0, len(games), 2):
        row = []
        row.append(InlineKeyboardButton(games[i][1], callback_data=f"support_{games[i][0]}"))
        if i + 1 < len(games):
            row.append(InlineKeyboardButton(games[i+1][1], callback_data=f"support_{games[i+1][0]}"))
        keyboard.append(row)

    return InlineKeyboardMarkup(keyboard)

def create_timing_keyboard():
    """Cria teclado inline para sele√ß√£o de timing"""
    keyboard = []
    for key, value in SupportFormManager.TIMING_OPTIONS.items():
        keyboard.append([InlineKeyboardButton(value, callback_data=f"support_{key}")])

    return InlineKeyboardMarkup(keyboard)

def create_confirmation_keyboard():
    """Cria teclado inline para confirma√ß√£o final"""
    keyboard = [
        [InlineKeyboardButton("‚úÖ CONFIRMAR E CRIAR ATENDIMENTO", callback_data="support_confirm")],
        [InlineKeyboardButton("üìù REVISAR INFORMA√á√ïES", callback_data="support_review")],
        [InlineKeyboardButton("‚ùå CANCELAR", callback_data="support_cancel")]
    ]
    return InlineKeyboardMarkup(keyboard)

async def process_category_selection(user_id: int, category: str, form_data: dict, username: str):
    """Processa sele√ß√£o de categoria"""
    try:
        form_data['category'] = category
        form_data['category_name'] = SupportFormManager.CATEGORIES.get(category, category)

        # Atualiza conversa para pr√≥ximo passo
        update_support_conversation(user_id, 2, 'game_selection', json.dumps(form_data))

        # Envia pergunta sobre jogo
        game_text = (
            f"üéÆ <b>Entendi! E me conta, qual jogo est√° sendo mais afetado?</b>\n\n"
            f"üî• <b>POPULARES:</b>"
        )

        keyboard = create_game_keyboard()

        bot = Bot(token=TELEGRAM_TOKEN)
        async with bot:
            await bot.send_message(
                chat_id=user_id,
                text=game_text,
                parse_mode='HTML',
                reply_markup=keyboard
            )

            # Atualiza progress
            progress_text = "üéØ <b>CRIANDO SEU ATENDIMENTO</b> [‚ñì‚ñì‚ñë‚ñë‚ñë‚ñë] 2/6\n\n‚úÖ Tipo do problema: " + form_data['category_name'] + "\nüîÑ Jogo afetado...\n‚è≥ Quando come√ßou...\n‚è≥ Detalhes...\n‚è≥ Anexos (opcional)...\n‚è≥ Confirma√ß√£o..."
            await bot.send_message(
                chat_id=user_id,
                text=progress_text,
                parse_mode='HTML'
            )

    except Exception as e:
        logger.error(f"Erro ao processar sele√ß√£o de categoria para {username}: {e}")

async def process_game_selection(user_id: int, game: str, form_data: dict, username: str):
    """Processa sele√ß√£o de jogo"""
    try:
        form_data['game'] = game
        form_data['game_name'] = SupportFormManager.POPULAR_GAMES.get(game, game)

        # Atualiza conversa para pr√≥ximo passo
        update_support_conversation(user_id, 3, 'timing_selection', json.dumps(form_data))

        # Envia pergunta sobre timing
        timing_text = (
            f"‚è∞ <b>Para entender melhor a situa√ß√£o, quando voc√™ come√ßou a notar esse problema?</b>\n\n"
            f"üí≠ Isso me ajuda a identificar se √© algo pontual ou estrutural!"
        )

        keyboard = create_timing_keyboard()

        bot = Bot(token=TELEGRAM_TOKEN)
        async with bot:
            await bot.send_message(
                chat_id=user_id,
                text=timing_text,
                parse_mode='HTML',
                reply_markup=keyboard
            )

            # Atualiza progress
            progress_text = f"üéØ <b>CRIANDO SEU ATENDIMENTO</b> [‚ñì‚ñì‚ñì‚ñë‚ñë‚ñë] 3/6\n\n‚úÖ Tipo do problema: {form_data['category_name']}\n‚úÖ Jogo afetado: {form_data['game_name']}\nüîÑ Quando come√ßou...\n‚è≥ Detalhes...\n‚è≥ Anexos (opcional)...\n‚è≥ Confirma√ß√£o..."
            await bot.send_message(
                chat_id=user_id,
                text=progress_text,
                parse_mode='HTML'
            )

    except Exception as e:
        logger.error(f"Erro ao processar sele√ß√£o de jogo para {username}: {e}")

async def process_timing_selection(user_id: int, timing: str, form_data: dict, username: str):
    """Processa sele√ß√£o de timing"""
    try:
        form_data['timing'] = timing
        form_data['timing_name'] = SupportFormManager.TIMING_OPTIONS.get(timing, timing)

        # Atualiza conversa para pr√≥ximo passo
        update_support_conversation(user_id, 4, 'description_input', json.dumps(form_data))

        # Envia solicita√ß√£o de descri√ß√£o
        description_text = (
            f"üìù <b>Agora, me descreva o problema com suas palavras!</b>\n\n"
            f"Pode incluir:\n"
            f"‚Ä¢ üéØ O que exatamente acontece\n"
            f"‚Ä¢ üïê Em que hor√°rios √© pior\n"
            f"‚Ä¢ üìä Valores que voc√™ v√™ (ping, FPS, etc)\n"
            f"‚Ä¢ üîß O que j√° tentou fazer\n\n"
            f"‚å®Ô∏è <b>Digite abaixo (m√°ximo 500 caracteres):</b>\n\n"
            f"üí° Quanto mais detalhes, melhor ser√° nossa solu√ß√£o!"
        )

        bot = Bot(token=TELEGRAM_TOKEN)
        async with bot:
            await bot.send_message(
                chat_id=user_id,
                text=description_text,
                parse_mode='HTML'
            )

            # Atualiza progress
            progress_text = f"üéØ <b>CRIANDO SEU ATENDIMENTO</b> [‚ñì‚ñì‚ñì‚ñì‚ñë‚ñë] 4/6\n\n‚úÖ Tipo do problema: {form_data['category_name']}\n‚úÖ Jogo afetado: {form_data['game_name']}\n‚úÖ Quando come√ßou: {form_data['timing_name']}\nüîÑ Coletando detalhes...\n‚è≥ Anexos (opcional)...\n‚è≥ Confirma√ß√£o..."
            await bot.send_message(
                chat_id=user_id,
                text=progress_text,
                parse_mode='HTML'
            )

    except Exception as e:
        logger.error(f"Erro ao processar sele√ß√£o de timing para {username}: {e}")

async def process_description_step(user_id: int, description: str, form_data: dict, username: str):
    """Processa descri√ß√£o detalhada"""
    try:
        # Valida√ß√£o da descri√ß√£o
        if len(description.strip()) < 10:
            await send_description_too_short(user_id)
            return

        if len(description) > 500:
            description = description[:500] + "..."

        # Sanitiza descri√ß√£o
        clean_description = sanitize_description(description)
        form_data['description'] = clean_description

        # Atualiza conversa para anexos (passo 5)
        update_support_conversation(user_id, 5, 'attachments_optional', json.dumps(form_data))

        # Vai para passo de anexos opcionais
        await send_attachments_step(user_id, form_data, username)

    except Exception as e:
        logger.error(f"Erro ao processar descri√ß√£o para {username}: {e}")

async def send_attachments_step(user_id: int, form_data: dict, username: str):
    """Envia passo opcional de anexos"""
    try:
        attachments_text = (
            f"üìé <b>ANEXOS OPCIONAIS</b>\n\n"
            f"Voc√™ pode enviar imagens que ajudem nossa equipe t√©cnica a entender melhor o problema:\n\n"
            f"üì± <b>Tipos √∫teis de imagem:</b>\n"
            f"‚Ä¢ üìä Print do speedtest\n"
            f"‚Ä¢ üéÆ Screenshot do jogo com ping/lag\n"
            f"‚Ä¢ ‚öôÔ∏è Tela de configura√ß√µes de rede\n"
            f"‚Ä¢ üñ•Ô∏è Monitor de rede/task manager\n"
            f"‚Ä¢ üìã Mensagens de erro\n\n"
            f"üìé <b>Como anexar:</b>\n"
            f"‚Ä¢ Envie as imagens diretamente neste chat\n"
            f"‚Ä¢ M√°ximo de 3 imagens\n"
            f"‚Ä¢ Formatos aceitos: JPG, PNG\n\n"
            f"‚ö°Ô∏è Isso √© <b>opcional</b> - voc√™ pode pular se preferir!"
        )

        keyboard = create_attachments_keyboard()

        bot = Bot(token=TELEGRAM_TOKEN)
        async with bot:
            await bot.send_message(
                chat_id=user_id,
                text=attachments_text,
                parse_mode='HTML',
                reply_markup=keyboard
            )

            # Progress bar para anexos
            progress_text = f"üéØ <b>CRIANDO SEU ATENDIMENTO</b> [‚ñì‚ñì‚ñì‚ñì‚ñì‚ñë] 5/6\n\n‚úÖ Tipo do problema: {form_data['category_name']}\n‚úÖ Jogo afetado: {form_data['game_name']}\n‚úÖ Quando come√ßou: {form_data['timing_name']}\n‚úÖ Detalhes coletados\nüîÑ Anexos (opcional)...\n‚è≥ Confirma√ß√£o..."
            await bot.send_message(
                chat_id=user_id,
                text=progress_text,
                parse_mode='HTML'
            )

    except Exception as e:
        logger.error(f"Erro ao enviar passo de anexos para {username}: {e}")

async def process_attachments_step(user_id: int, action: str, form_data: dict, username: str):
    """Processa passo de anexos"""
    try:
        if action == "skip_attachments":
            # Pula anexos e vai para confirma√ß√£o
            form_data['attachments'] = []
            update_support_conversation(user_id, 6, 'confirmation', json.dumps(form_data))
            await send_confirmation_summary(user_id, form_data, username)
        elif action == "add_attachments":
            # Configura para receber imagens
            form_data['waiting_for_images'] = True
            form_data['attachments'] = []
            update_support_conversation(user_id, 5, 'attachments_optional', json.dumps(form_data))
            await send_waiting_for_images(user_id)
        elif action == "finalize_attachments":
            # Finaliza anexos e vai para confirma√ß√£o
            form_data.pop('waiting_for_images', None)
            update_support_conversation(user_id, 6, 'confirmation', json.dumps(form_data))
            await send_confirmation_summary(user_id, form_data, username)

    except Exception as e:
        logger.error(f"Erro ao processar anexos para {username}: {e}")

async def send_waiting_for_images(user_id: int):
    """Informa que est√° aguardando imagens"""
    try:
        waiting_text = (
            f"üì∏ <b>AGUARDANDO SUAS IMAGENS</b>\n\n"
            f"Envie at√© <b>3 imagens</b> uma de cada vez.\n\n"
            f"üìé Depois de enviar todas as imagens, clique em <b>'Finalizar Anexos'</b> para continuar.\n\n"
            f"‚ö†Ô∏è <b>Importante:</b> Envie apenas imagens (JPG/PNG)"
        )

        keyboard = create_finalize_attachments_keyboard()

        bot = Bot(token=TELEGRAM_TOKEN)
        async with bot:
            await bot.send_message(
                chat_id=user_id,
                text=waiting_text,
                parse_mode='HTML',
                reply_markup=keyboard
            )

    except Exception as e:
        logger.error(f"Erro ao enviar aguardando imagens: {e}")

def create_attachments_keyboard():
    """Cria teclado para escolha de anexos"""
    keyboard = [
        [InlineKeyboardButton("üìé Sim, vou anexar imagens", callback_data="support_add_attachments")],
        [InlineKeyboardButton("‚è≠Ô∏è Pular anexos e continuar", callback_data="support_skip_attachments")]
    ]
    return InlineKeyboardMarkup(keyboard)

def create_finalize_attachments_keyboard():
    """Cria teclado para finalizar anexos"""
    keyboard = [
        [InlineKeyboardButton("‚úÖ Finalizar anexos e continuar", callback_data="support_finalize_attachments")],
        [InlineKeyboardButton("‚ùå Cancelar anexos", callback_data="support_skip_attachments")]
    ]
    return InlineKeyboardMarkup(keyboard)

async def send_confirmation_summary(user_id: int, form_data: dict, username: str):
    """Envia resumo para confirma√ß√£o"""
    try:
        # Busca dados do usu√°rio
        user_data = get_user_data(user_id)
        client_name = user_data.get('client_name', 'Cliente') if user_data else 'Cliente'

        # Trunca descri√ß√£o para resumo
        description_preview = form_data['description'][:100] + "..." if len(form_data['description']) > 100 else form_data['description']

        # Informa√ß√µes sobre anexos
        attachments = form_data.get('attachments', [])
        attachments_info = ""
        if attachments:
            attachments_info = f"üìé <b>Anexos:</b> {len(attachments)} imagem(ns) anexada(s)\n"
        else:
            attachments_info = f"üìé <b>Anexos:</b> Nenhum anexo\n"

        summary_text = (
            f"‚úÖ <b>RESUMO DO SEU ATENDIMENTO:</b>\n\n"
            f"üë§ <b>Cliente:</b> {client_name}\n"
            f"üéÆ <b>Problema:</b> {form_data['category_name']}\n"
            f"üéØ <b>Jogo:</b> {form_data['game_name']}\n"
            f"‚è∞ <b>Iniciado:</b> {form_data['timing_name']}\n"
            f"üìù <b>Detalhes:</b> \"{description_preview}\"\n"
            f"{attachments_info}\n"
            f"üî• <b>Vou criar seu atendimento oficial agora!</b>\n\n"
            f"‚ö°Ô∏è Em poucos segundos voc√™ ter√° seu protocolo!"
        )

        keyboard = create_confirmation_keyboard()

        bot = Bot(token=TELEGRAM_TOKEN)
        async with bot:
            await bot.send_message(
                chat_id=user_id,
                text=summary_text,
                parse_mode='HTML',
                reply_markup=keyboard
            )

            # Progress final
            attachments_status = f"‚úÖ Anexos: {len(form_data.get('attachments', []))} imagem(ns)" if form_data.get('attachments') else "‚úÖ Anexos: Nenhum"
            progress_text = f"üéØ <b>CRIANDO SEU ATENDIMENTO</b> [‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì] 6/6\n\n‚úÖ Tipo do problema: {form_data['category_name']}\n‚úÖ Jogo afetado: {form_data['game_name']}\n‚úÖ Quando come√ßou: {form_data['timing_name']}\n‚úÖ Detalhes coletados\n{attachments_status}\nüîÑ Aguardando confirma√ß√£o..."
            await bot.send_message(
                chat_id=user_id,
                text=progress_text,
                parse_mode='HTML'
            )

    except Exception as e:
        logger.error(f"Erro ao enviar resumo de confirma√ß√£o para {username}: {e}")

async def process_confirmation(user_id: int, action: str, form_data: dict, username: str):
    """Processa confirma√ß√£o final"""
    try:
        if action == "confirm":
            await create_support_ticket(user_id, form_data, username)
        elif action == "review":
            # Volta para categoria
            update_support_conversation(user_id, 1, 'category_selection', '{}')
            await send_welcome_support_message(user_id, get_user_data(user_id), f"@{username}")
        elif action == "cancel":
            # Cancela formul√°rio
            update_support_conversation(user_id, 0, 'cancelled', json.dumps(form_data))
            await send_cancellation_message(user_id)

    except Exception as e:
        logger.error(f"Erro ao processar confirma√ß√£o para {username}: {e}")

async def create_support_ticket(user_id: int, form_data: dict, username: str):
    """Cria ticket de suporte final"""
    try:
        from src.sentinela.services.tech_notification_service import notify_tech_team_new_ticket
        from src.sentinela.integrations.hubsoft.atendimento import hubsoft_atendimento_client
        from src.sentinela.integrations.hubsoft.config import format_protocol

        # Busca dados do cliente
        user_data = get_user_data(user_id)
        if not user_data:
            await send_error_message(user_id, "Erro: dados do cliente n√£o encontrados")
            return

        # Monta dados do ticket para HubSoft
        ticket_data = {
            'user_id': user_id,
            'username': username,
            'user_mention': f"@{username}",
            'cpf': user_data.get('cpf', ''),
            'client_name': user_data.get('client_name', ''),
            'category': form_data['category'],
            'affected_game': form_data['game'],
            'problem_started': form_data['timing'],
            'description': form_data['description'],
            'urgency_level': calculate_urgency(form_data),
            'topic_thread_id': 148  # ID do t√≥pico de suporte
        }

        # Tenta criar atendimento no HubSoft primeiro
        hubsoft_id = None
        protocol = None
        hubsoft_success = False

        try:
            logger.info(f"Criando atendimento HubSoft para usu√°rio {username}")
            hubsoft_response = await hubsoft_atendimento_client.create_atendimento(
                client_cpf=user_data.get('cpf', ''),
                ticket_data=ticket_data
            )

            # Usa estrutura correta da resposta da API
            if hubsoft_response:
                hubsoft_id = hubsoft_response.get('id_atendimento')
                protocol = hubsoft_response.get('protocolo')

                if hubsoft_id and protocol:
                    hubsoft_success = True
                    logger.info(f"Atendimento HubSoft criado com sucesso: ID {hubsoft_id}, Protocolo: {protocol}")

                    # Salva no banco local com ID do HubSoft
                    ticket_data['hubsoft_atendimento_id'] = hubsoft_id
                    ticket_data['protocolo'] = protocol
                    ticket_id = save_support_ticket(ticket_data)

                    # Adiciona mensagem inicial com contexto enriquecido do bot
                    attachments_info = ""
                    attachments = form_data.get('attachments', [])
                    if attachments:
                        attachments_info = f"‚Ä¢ Anexos: {len(attachments)} imagem(ns) anexada(s)\n"

                    await hubsoft_atendimento_client.add_message_to_atendimento(
                        str(hubsoft_id),
                        f"ü§ñ Bot Telegram OnCabo: Atendimento criado via formul√°rio conversacional interativo.\n\n"
                        f"üì± Dados da sess√£o:\n"
                        f"‚Ä¢ User: @{username} (ID: {user_id})\n"
                        f"‚Ä¢ Categoria: {SupportFormManager.CATEGORIES.get(form_data['category'], form_data['category'])}\n"
                        f"‚Ä¢ Jogo: {SupportFormManager.POPULAR_GAMES.get(form_data['game'], form_data['game'])}\n"
                        f"‚Ä¢ Timing: {SupportFormManager.TIMING_OPTIONS.get(form_data['timing'], form_data['timing'])}\n"
                        f"‚Ä¢ Urg√™ncia: {calculate_urgency(form_data)}\n"
                        f"{attachments_info}"
                        f"‚Ä¢ Conclu√≠do: {datetime.now().strftime('%d/%m/%Y √†s %H:%M')}\n\n"
                        f"üéØ Cliente guiado atrav√©s do formul√°rio inteligente para coleta precisa de informa√ß√µes."
                    )

                    # Envia anexos para o HubSoft se existirem
                    if attachments:
                        await process_hubsoft_attachments(str(hubsoft_id), attachments, username)
                else:
                    raise Exception("Resposta da API sem ID ou protocolo v√°lido")
            else:
                raise Exception("Resposta vazia da API HubSoft")

        except Exception as hubsoft_error:
            logger.error(f"Erro ao criar atendimento no HubSoft: {hubsoft_error}")

            # Fallback: salva apenas localmente
            logger.info("Salvando ticket apenas no banco local como fallback")
            ticket_id = save_support_ticket(ticket_data)
            protocol = f"ATD{ticket_id:06d}" if ticket_id else "ERRO"
            hubsoft_success = False

        # Se n√£o conseguiu criar no HubSoft, usa fallback local
        if not hubsoft_success:
            logger.warning(f"Atendimento salvo apenas localmente como fallback: {protocol}")

        # Envia notifica√ß√£o para canal t√©cnico
        await notify_tech_team_new_ticket(ticket_data, user_data, protocol)

        # Envia confirma√ß√£o para o usu√°rio
        await send_ticket_created_success(user_id, protocol, form_data, user_data)

        logger.info(f"Ticket de suporte criado com sucesso: {protocol}")

    except Exception as e:
        logger.error(f"Erro ao criar ticket de suporte para {username}: {e}")
        await send_error_message(user_id, "Erro interno ao criar atendimento")

def calculate_urgency(form_data: dict) -> str:
    """Calcula urg√™ncia do ticket baseado nos dados"""
    category = form_data.get('category', '')
    timing = form_data.get('timing', '')

    # Alta urg√™ncia para problemas de conectividade que come√ßaram agora
    if category == 'connectivity' and timing in ['now', 'yesterday']:
        return 'high'

    # M√©dia para problemas de performance
    if category == 'performance':
        return 'medium'

    return 'normal'

def sanitize_description(text: str) -> str:
    """Sanitiza descri√ß√£o do problema"""
    # Remove caracteres especiais desnecess√°rios
    import re

    # Remove m√∫ltiplos espa√ßos
    text = re.sub(r'\s+', ' ', text)

    # Capitaliza primeira letra
    text = text.strip().capitalize()

    return text

async def send_ticket_created_success(user_id: int, protocol: str, form_data: dict, user_data: dict):
    """Envia mensagem de sucesso na cria√ß√£o do ticket"""
    try:
        client_name = user_data.get('client_name', 'Cliente')
        current_time = datetime.now().strftime("%d/%m/%Y √†s %H:%M")

        success_text = (
            f"üéâ <b>ATENDIMENTO CRIADO COM SUCESSO!</b>\n\n"
            f"üìã <b>Protocolo:</b> {protocol}\n"
            f"üë§ <b>Cliente:</b> {client_name}\n"
            f"üïí <b>Criado:</b> {current_time}\n"
            f"‚ö°Ô∏è <b>Prioridade:</b> {get_priority_text(calculate_urgency(form_data))}\n\n"
            f"‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n"
            f"‚úÖ <b>O QUE ACONTECE AGORA:</b>\n\n"
            f"1Ô∏è‚É£ Nossa equipe t√©cnica foi notificada\n"
            f"2Ô∏è‚É£ An√°lise inicial em at√© 30 minutos\n"
            f"3Ô∏è‚É£ Retorno com diagn√≥stico em at√© 4 horas\n"
            f"4Ô∏è‚É£ Resolu√ß√£o completa conforme complexidade\n\n"
            f"‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n"
            f"üìû <b>ACOMPANHE SEU ATENDIMENTO:</b>\n"
            f"‚Ä¢ No t√≥pico üÜò Suporte Gamer\n"
            f"‚Ä¢ Mencione o protocolo {protocol}\n"
            f"‚Ä¢ Ou chame @suporte_oncabo\n\n"
            f"‚ö°Ô∏è <b>RESOLU√á√ÉO R√ÅPIDA COMUM EM:</b>\n"
            f"üéÆ Ping/Lag: Otimiza√ß√£o imediata\n"
            f"‚öôÔ∏è Configura√ß√£o: Orienta√ß√£o t√©cnica\n"
            f"üîß Equipamento: Agendamento se necess√°rio\n\n"
            f"üöÄ <b>Relaxa que vamos resolver! A OnCabo cuida dos seus games!</b> üí™"
        )

        bot = Bot(token=TELEGRAM_TOKEN)
        async with bot:
            await bot.send_message(
                chat_id=user_id,
                text=success_text,
                parse_mode='HTML'
            )

    except Exception as e:
        logger.error(f"Erro ao enviar mensagem de sucesso: {e}")

def get_priority_text(priority: str) -> str:
    """Converte prioridade para texto amig√°vel"""
    priority_map = {
        'high': 'Alta (problema cr√≠tico)',
        'medium': 'M√©dia (problema de performance)',
        'normal': 'Normal (suporte geral)'
    }
    return priority_map.get(priority, 'Normal')

# Mensagens de erro e bloqueio
async def send_support_blocked_message(user_id: int, permission: dict):
    """Envia mensagem quando usu√°rio est√° bloqueado"""
    try:
        reason = permission['reason']

        if reason == 'active_ticket':
            # Busca tickets ativos
            active_tickets = get_active_support_tickets(user_id)
            ticket_info = f"#{active_tickets[0]['id']:06d}" if active_tickets else "#ATD000000"

            message = (
                f"üéÆ <b>Ol√°!</b> Vejo que voc√™ j√° tem um atendimento em andamento ({ticket_info}).\n\n"
                f"üìû Nossa equipe est√° trabalhando no seu caso!\n\n"
                f"üí° <b>Para agilizar, voc√™ pode:</b>\n"
                f"‚Ä¢ Aguardar retorno da equipe t√©cnica\n"
                f"‚Ä¢ Adicionar informa√ß√µes ao chamado existente\n"
                f"‚Ä¢ Verificar status pelo n√∫mero do protocolo\n\n"
                f"‚è∞ <b>Tempo m√©dio de resposta:</b> 2-4 horas √∫teis"
            )
        elif reason == 'daily_limit':
            message = (
                f"‚ö†Ô∏è <b>Percebo que voc√™ j√° abriu alguns chamados recentemente.</b>\n\n"
                f"üïí Para garantir qualidade no atendimento, h√° um limite de 3 chamados por dia.\n\n"
                f"üìû Nossa equipe est√° analisando seus casos anteriores.\n\n"
                f"üîÑ Voc√™ poder√° abrir um novo chamado amanh√£."
            )
        else:
            message = f"‚ö†Ô∏è {permission['message']}\n\nTente novamente mais tarde."

        bot = Bot(token=TELEGRAM_TOKEN)
        async with bot:
            await bot.send_message(
                chat_id=user_id,
                text=message,
                parse_mode='HTML'
            )

    except Exception as e:
        logger.error(f"Erro ao enviar mensagem de bloqueio: {e}")

async def send_client_not_found_message(user_id: int):
    """Envia mensagem quando cliente n√£o √© encontrado"""
    message = (
        f"‚ùå <b>Cliente n√£o encontrado</b>\n\n"
        f"Para usar o suporte, voc√™ precisa ser um cliente OnCabo verificado.\n\n"
        f"üìù Use o comando /start para validar seu CPF primeiro."
    )

    bot = Bot(token=TELEGRAM_TOKEN)
    async with bot:
        await bot.send_message(
            chat_id=user_id,
            text=message,
            parse_mode='HTML'
        )

async def send_error_message(user_id: int, error_msg: str):
    """Envia mensagem de erro gen√©rica"""
    message = f"‚ùå <b>Erro:</b> {error_msg}\n\nTente novamente ou entre em contato com o suporte."

    bot = Bot(token=TELEGRAM_TOKEN)
    async with bot:
        await bot.send_message(
            chat_id=user_id,
            text=message,
            parse_mode='HTML'
        )

async def send_description_too_short(user_id: int):
    """Envia mensagem quando descri√ß√£o √© muito curta"""
    message = (
        f"üìù <b>Descri√ß√£o muito curta!</b>\n\n"
        f"Para que possamos te ajudar melhor, preciso de pelo menos 10 caracteres descrevendo o problema.\n\n"
        f"üí° <b>Tente incluir:</b>\n"
        f"‚Ä¢ O que est√° acontecendo\n"
        f"‚Ä¢ Quando acontece\n"
        f"‚Ä¢ Que valores voc√™ v√™\n\n"
        f"‚å®Ô∏è <b>Digite uma descri√ß√£o mais detalhada:</b>"
    )

    bot = Bot(token=TELEGRAM_TOKEN)
    async with bot:
        await bot.send_message(
            chat_id=user_id,
            text=message,
            parse_mode='HTML'
        )

async def send_cancellation_message(user_id: int):
    """Envia mensagem de cancelamento"""
    message = (
        f"‚ùå <b>Formul√°rio cancelado</b>\n\n"
        f"Sem problemas! Se precisar de ajuda depois, √© s√≥ usar /suporte novamente.\n\n"
        f"üéÆ A OnCabo est√° sempre aqui para te ajudar!"
    )

    bot = Bot(token=TELEGRAM_TOKEN)
    async with bot:
        await bot.send_message(
            chat_id=user_id,
            text=message,
            parse_mode='HTML'
        )